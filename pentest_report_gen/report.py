import os
import json
import subprocess
from datetime import datetime
from jinja2 import Environment, FileSystemLoader, select_autoescape

class ReportGenerationError(Exception):
    """Eccezione sollevata in caso di errore durante la generazione del report."""
    pass

def load_cve_mapping():
    """Carica il file JSON di mappatura CVE->CWE/CVSS/severità/raccomandazione."""
    mapping_path = os.path.join(os.path.dirname(__file__), os.pardir, "data", "cve_cwe_map.json")
    try:
        with open(mapping_path, "r", encoding="utf-8") as f:
            data = json.load(f)
    except FileNotFoundError:
        data = {}
    except json.JSONDecodeError as e:
        raise ReportGenerationError(f"Formato JSON non valido in cve_cwe_map.json: {e}")
    return data

def generate_report(data, output_path, style="semplice", output_format="md"):
    """
    Genera un report di sicurezza in formato Markdown o PDF a partire dai dati estratti.
    - data: dizionario ritornato da parser.parse_nmap_xml.
    - output_path: percorso del file di output da creare.
    - style: 'semplice' o 'corporate' per selezionare il template.
    - output_format: 'md' per Markdown, 'pdf' per PDF.
    """
    # Carica la mappatura CVE->CWE/CVSS/severità/raccomandazione
    cve_map = load_cve_mapping()

    # Enrichimento dei dati delle vulnerabilità con informazioni di CWE, severità e raccomandazioni
    severity_map = {
        "Critical": "Critica",
        "High": "Alta",
        "Medium": "Media",
        "Low": "Bassa"
    }
    total_vulns = 0
    severity_counts = {"Critica": 0, "Alta": 0, "Media": 0, "Bassa": 0}
    for host in data.get("hosts", []):
        for port in host.get("ports", []):
            for vuln in port.get("vulns", []):
                cve_id = vuln.get("cve")
                # Imposta chiavi di default
                vuln.setdefault("cvss", None)
                vuln.setdefault("severity", None)
                vuln.setdefault("cwe", None)
                vuln.setdefault("recommendation", None)
                if cve_id and cve_id in cve_map:
                    # Usa i dettagli dal mapping JSON se disponibili
                    details = cve_map[cve_id]
                    vuln["cwe"] = details.get("CWE")
                    # Se nel mapping esiste un CVSS (magari aggiornato) lo usa, altrimenti mantiene quello parsato
                    if "CVSS" in details:
                        try:
                            vuln["cvss"] = float(details["CVSS"])
                        except:
                            vuln["cvss"] = details["CVSS"]
                    # Usa la severità dal mapping (già in lingua locale)
                    if "severity" in details:
                        vuln["severity"] = details["severity"]
                    # Usa raccomandazione dal mapping
                    vuln["recommendation"] = details.get("recommendation")
                else:
                    # Se non abbiamo dettagli predefiniti, calcoliamo severità da CVSS se possibile
                    score = vuln.get("cvss")
                    if score is not None:
                        # Determina categoria di severità basata sul punteggio CVSS
                        if score >= 9.0:
                            vuln["severity"] = "Critica"
                        elif score >= 7.0:
                            vuln["severity"] = "Alta"
                        elif score >= 4.0:
                            vuln["severity"] = "Media"
                        else:
                            vuln["severity"] = "Bassa"
                    else:
                        vuln["severity"] = "Sconosciuta"
                # Aggiorna conteggio complessivo delle vulnerabilità per severità
                if vuln["severity"] in ["Critica", "Alta", "Media", "Bassa"]:
                    severity_counts[vuln["severity"]] += 1
                    total_vulns += 1

    # Prepara i dati da inserire nel template
    template_data = {
        "hosts": data.get("hosts", []),
        "stats": data.get("stats", {}),
        "generated_on": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "total_vulns": total_vulns,
        "severity_counts": {sev: cnt for sev, cnt in severity_counts.items() if cnt > 0}
    }

    # Imposta il caricatore di template Jinja2 dalla cartella "templates"
    templates_dir = os.path.join(os.path.dirname(__file__), os.pardir, "templates")
    env = Environment(loader=FileSystemLoader(templates_dir), autoescape=select_autoescape([]))
    try:
        template = env.get_template(f"{style}.md.j2")
    except Exception as e:
        raise ReportGenerationError(f"Impossibile caricare il template per lo stile '{style}': {e}")

    # Genera il contenuto Markdown tramite il template
    try:
        markdown_content = template.render(data=template_data)
    except Exception as e:
        raise ReportGenerationError(f"Errore nel rendering del template: {e}")

    # Salva il markdown generato o effettua la conversione in PDF
    output_format = output_format.lower()
    if output_format == "md":
        # Salva il contenuto Markdown su file
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(markdown_content)
    elif output_format == "pdf":
        # Tenta la conversione in PDF usando pandoc
        try:
            # Avvia pandoc passando il contenuto Markdown via stdin e generando PDF
            subprocess.run(["pandoc", "-f", "markdown", "-t", "pdf", "-o", output_path],
                           input=markdown_content.encode("utf-8"), check=True)
        except FileNotFoundError:
            # pandoc non installato o non trovato
            raise ReportGenerationError("Pandoc non trovato. Impossibile convertire in PDF.")
        except subprocess.CalledProcessError as e:
            raise ReportGenerationError(f"Errore di conversione PDF: {e}")
    else:
        raise ReportGenerationError(f"Formato di output sconosciuto: {output_format}")
